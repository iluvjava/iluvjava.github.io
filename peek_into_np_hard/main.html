<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width">
    <title>Peek Into Np-Hard</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
    </script>
  </head>
  <body>
    <section>
      <h1>
      Introduction
      </h1>
      <p>
        The Knapsack Problem is the best problem to learn about NP-Hardness 
        because it's simple, in terms of how the problem is defined. 
        <br>
        It's simple also because it's approximation algorithm is not NP-Hard.
      </p>
      <p>
        Formulation of the Knapsack problem: 
        \(\max\{\sum_{i=1}^n p_ix_i : \sum_{i=1}^n w_i x_i \leq b\wedge x\in\{0, 1\}^n \}\)
        and here is a list of constraints I defined: 
      </p>
      <ol>
        <li>
          For all item's profits: \(p_i \in \mathbb{R}_+\)
        </li>
        <li>
          For all item's weight: \(0 \leq w_i \leq b\)
        </li>
      </ol>
    </section>
    <section>
      <h1>
        Dynamic Programming
      </h1>
      <p>
        Dynamic Programming is possible if one of the value, \(\vec{w}\) or 
        \(\vec{p}\) is a vector of integers. This makes things easy because 
        the number of subsets of solution sharing the same profits/weights are 
        more than 1. 
        <br>
        For the contrary, imagine the weights and profits of the item is random 
        points on the real number line, then it's impossible to have the 
        different subsets having the same profits/weights. 
        <br>
        There are 2 solution to solving the Knapsack problem: 
        <ol>
          <li>Primal: Maximizing the profits for a certain amount of weights.</li>
          <li>Dual: Minimizing the weights for a certain amount profits. </li>
        </ol>
        This is one of the applications of duality in Linear Programming. 
      </p>
      
      <h2>Primal</h2>
      <p>
        Inputs: \(\forall w_i : w_i \in \mathbb{Z}_+\), \(\forall p_i: p_i \in \mathbb{R}_+\)
        <br>
        Observe that, one of the vector can have numbers that are real. 
        <ul>
          <li>
            T[j, w] := the profits of items using sub array from 0 to j such 
            that it sums up to weight of exactly w. 
            <br>
            It's up to the reader to make of sense that: \(0 \leq j \leq n-1\),
            \(0\leq w \leq b\)
          </li>
          <li>
            The recurrence relation: 
            <ul>
              <li>T[j + 1, w] := max(T[j, w - \(w_j\)] + \(p_{j+1}\), T[j, w])</li>
              <li>If w - \(w_j\) < 0 then just ignore that case. </li>
            </ul>
          </li>
          <li>
            Base Cases: 
            <ul>
              <li>T[-1, \(\forall \)] := -inf</li>
              <li>T[-1, 0] := 0</li>
            </ul>
          </li>
          <li>
            Order for updating: column, by columns. 
          </li>
          <li>
            Optimization: 
            <ul>
              <li>
                Only the previous column of T is used for each iteration, so that can be simplied by storing only previous column. 
              </li>
              <li>
                We need to keep track of the solution using a dictionary. 
              </li>
            </ul>
          </li>
          <li>
            On the table, look for entry maximizes value of T[j, w]. 
          </li>
        </ul>    
        The complexity of the primral exact algorithm is the size o the table: 
        \(\mathcal{O}(n*b)\)
      </p>
      <h2>Dual</h2>
      <p>
        The dual tries to minimize the weight of the solution for a fixed 
        profits. And it allows weights to be positive real, and the profits has to be integers.
        <br>
        Inputs: \(\forall p_i: p_i \in \mathbb{Z}_+\), \(\forall w_i: w_i \in \mathbb{R}_+\)
        <ul>
          <li>
            Definition of table: T[j, p]: The minimum of weights such that it gives exactly a profits of p. 
          </li>
          <li>
            Recurrence: 
            <ul>
              <li> T[j, p] := min(T[j - 1, p - \(p_j\)] + \(w_j\), T[j - 1, p])</li>
              <li>If p - \(p_j\) < 0, then just ignore that case. </li>
            </ul>
           
          </li>
          <li>
            Order of update: column by columns. 
          </li>
          <li>
            Base cases: 
            <ul>
              <li>T[-1, \(\forall\)] := \(+\inf\);</li>
              <li> T[-1, 0]:= 0 </li>
            </ul>
          </li>
        </ul>
        The dual formulation will have a table with this many rows: \(\sum_{i} p_i\);  But The upper bound for profits 
        can be reduced using approximation algorithm: Greedy Algorithm. 
      </p>
    </section>
    <section>
      <h1>Approximation Algorithms</h1>
      <h2>Greedy Algorithm</h2>
      <h2>Primal with Rounding</h2>
      <h2>Dual with Rounding</h2>
    </section>
  </body>
</html>