<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Peek Into Np-Hard</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js">
    </script>
  </head>
  <body>
    <section>
      <h1>
      Introduction
      </h1>
      <p>
        The Knapsack Problem is the best problem to learn about NP-Hardness 
        because it's simple, in terms of how the problem is defined. 
        <br>
        It's simple also because it's approximation algorithm is not NP-Hard.
      </p>
      <p>
        Formulation of the Knapsack problem: 
        \(\max\{\sum_{i=1}^n p_ix_i : \sum_{i=1}^n w_i \leq b\wedge x\in\{0, 1\}^n \}\)
        and here is a list of constraints I defined: 
      </p>
      <ol>
        <li>
          For all item's profits: \(p_i \in \mathbb{R}_+\)
        </li>
        <li>
          For all item's weight: \(0 \leq w_i \leq b\)
        </li>
      </ol>
    </section>
    <section>
      <h1>
        Dynamic Programming
      </h1>
      <p>
        Dynamic Programming is possible if one of the value, \(\vec{w}\) or 
        \(\vec{p}\) is a vector of integers. This makes things easy because 
        the number of subsets of solution sharing the same profits/weights are 
        more than 1. 
        <br>
        For the contrary, imagine the weights and profits of the item is random 
        points on the real number line, then it's impossible to have the 
        different subsets having the same profits/weights. 
      </p>
    </section>
    <section>
      <h1>Approximation Algorithms</h1>
    </section>
    
  </body>
</html>